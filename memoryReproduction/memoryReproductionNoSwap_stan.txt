// memory reproduction model with no swap errors

data {
  int<lower=2> nStimuli;  // Number of unique stimuli
  int<lower=1> nTrials;   // Number of experimental trials
  
  // FIX: Constraint on setSize is now 1 or 2, as it acts as a direct index.
  array[nTrials] int<lower=1, upper=2> setSize; // Set size index for each trial (1 or 2)
  
  array[nTrials, 6] int<lower=1> stim; // The actual stimuli presented on each trial
  array[nTrials] real y; // The observed response (reproduced angle)
}

parameters {
  // Memory Noise (Standard Deviation)
  array[2] real<lower=0, upper=pi()> sigma; // sigma[1] for setSize index 1, sigma[2] for setSize index 2
  
  // Stimulus Mean Locations (mu[1] is fixed to 0)
  real<lower=0, upper=pi()/2> mu2; // Represents mu[2]
  array[nStimuli - 2] real<lower=0, upper=pi()> mu_others; // Represents mu[3] to mu[nStimuli]
}

transformed parameters {
  // Combine the fixed and parameterized mu values
  array[nStimuli] real mu;
  mu[1] = 0;
  mu[2] = mu2;
  for (j in 1:(nStimuli - 2)) {
    mu[j + 2] = mu_others[j];
  }
}

model {
  // --- Priors ---

  // Memory Noise priors 
  sigma[1] ~ uniform(0, pi());
  sigma[2] ~ uniform(0, pi());
  
  // --- Likelihood (No Mixture Model) ---
  
  for (t in 1:nTrials) {
    // FIX: Directly use setSize[t] as the index for sigma.
    // setSize[t] is 1 (for 3-stim case) or 2 (for 6-stim case).
    int current_size_idx = setSize[t]; 
    
    // The target is always the first stimulus in the array (stim[t, 1])
    int target_stim_idx = stim[t, 1];
    
    // Noise parameter: sigma[current_size_idx]
    real noise_std = sigma[current_size_idx];
    
    // Mean parameter: mu[target_stim_idx]
    real noise_mean = mu[target_stim_idx];
    
    // Response: y[t] ~ normal(mean, std)
    y[t] ~ normal(noise_mean, noise_std);
  }
}