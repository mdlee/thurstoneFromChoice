// memory reproduction model
data {
  // Fixed error: Changed int nStimuli; to int<lower=2> nStimuli; for consistency
  int<lower=2> nStimuli; // Number of unique stimuli (must be at least 2)
  int<lower=1> nTrials;  // Number of experimental trials
  
  // FIX: Old syntax 'int setSize[nTrials];' -> New syntax 'array[nTrials] int<lower=1> setSize;'
  array[nTrials] int<lower=1> setSize; // Size of the stimulus set for each trial (likely 3 or 6)
  
  // FIX: Old syntax 'int stim[nTrials, 6];' -> New syntax 'array[nTrials, 6] int<lower=1> stim;'
  array[nTrials, 6] int<lower=1> stim; // The actual stimuli presented on each trial (up to 6 slots)
  
  // FIX: Old syntax 'real y[nTrials];' -> New syntax 'array[nTrials] real y;'
  array[nTrials] real y; // The observed response (reproduced angle)
}

parameters {
  // Memory Noise (Standard Deviation)
  // FIX: Old syntax 'real sigma[2];' -> New syntax 'array[2] real<lower=0, upper=pi()> sigma;'
  array[2] real<lower=0, upper=pi()> sigma; // sigma[1] for setSize 3, sigma[2] for setSize 6
  
  // Stimulus Mean Locations (mu[1] is fixed to 0, so we only need 2:nStimuli)
  real<lower=0, upper=pi()/2> mu2; // Represents mu[2]
  // FIX: Old syntax 'real mu_others[nStimuli - 2];' -> New syntax 'array[nStimuli - 2] real<lower=0, upper=pi()> mu_others;'
  array[nStimuli - 2] real<lower=0, upper=pi()> mu_others; // Represents mu[3] to mu[nStimuli]
  
  // Swap Error Probabilities (Dirichlet distribution)
  simplex[3] omega3; // For setSize 3
  simplex[6] omega6; // For setSize 6
}

transformed parameters {
  // Combine the fixed and parameterized mu values
  // FIX: Old syntax 'real mu[nStimuli];' -> New syntax 'array[nStimuli] real mu;'
  array[nStimuli] real mu;
  mu[1] = 0;
  mu[2] = mu2;
  for (j in 1:(nStimuli - 2)) {
    mu[j + 2] = mu_others[j];
  }
}

model {
  // --- Priors ---
  // Priors remain the same (implicit uniform for bounded parameters, explicit Dirichlet)
  sigma[1] ~ uniform(0, pi());
  sigma[2] ~ uniform(0, pi());
  
  omega3 ~ dirichlet(rep_vector(1, 3));
  omega6 ~ dirichlet(rep_vector(1, 6));

  // --- Likelihood (Mixture Model Marginalization) ---
  for (t in 1:nTrials) {
    int current_size = setSize[t];
    
    if (current_size == 1) {
      vector[3] log_prob;
      
      for (k in 1:3) {
        log_prob[k] = log(omega3[k]) + 
                      normal_lpdf(y[t] | mu[stim[t, k]], sigma[1]);
      }
      
      target += log_sum_exp(log_prob);
      
    } else if (current_size == 2) {
      vector[6] log_prob;
      
      for (k in 1:6) {
        log_prob[k] = log(omega6[k]) + 
                      normal_lpdf(y[t] | mu[stim[t, k]], sigma[2]);
      }
      
      target += log_sum_exp(log_prob); 
      
    } else {
      reject("Set size index must be 1 (= 2 foils and a target) or 2 (= 5 foils and a target), but got ", current_size);
    }
  }
}